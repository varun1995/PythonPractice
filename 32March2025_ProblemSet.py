"""
### ✅ **1. Scenario: Web Scraping – Clean Product Tags**

**Context**:
Your team is scraping e-commerce websites to collect **product tags** for recommendation models.
However, these tags sometimes come with unwanted **leading and trailing spaces** which interfere with matching logic.
You need to build a utility to remove extra spaces from all tags.

**Task**:
Write a function that takes a string and returns it after removing any leading and trailing spaces.

"""
def q1():
    product_tags = [
        "   Electronics   ",  # Leading and trailing spaces
        "HomeAppliances",  # No spaces
        "  Gaming",  # Leading space
        "Clothing  ",  # Trailing space
        "   ",  # Only spaces
        ""  # Empty string
    ]

    final_list = []

    for product in product_tags:
        temp_str = ""
        temp_list = []

        if product != "":
            for char in product:
                if char == " ":
                    continue
                else:
                    temp_str += char

            if temp_str != "":
                final_list.append(temp_str)
        else:
            print(f"Product details not found!")
            continue


    print(f"Required list: {final_list}")

"""

### ✅ **2. Scenario: Mobile App Analytics – Count API Errors**

**Context**:
You are analyzing API logs generated by a mobile app to report the number of times the
app faced a **specific error** during user sessions. Given a list of error codes, you are required
to count how many times a specific error code occurred.

**Task**:
Write a function that counts how many times a target error code appears in a list of error codes.

error_logs = [
    "ERR_TIMEOUT",
    "ERR_NETWORK",
    "ERR_AUTH",
    "ERR_TIMEOUT",
    "ERR_UNKNOWN",
    "ERR_TIMEOUT",
    "ERR_AUTH"
]

target_error = "ERR_TIMEOUT"    # Expected count = 3

"""
def q2():
    error_logs = [
        "ERR_TIMEOUT",
        "ERR_NETWORK",
        "ERR_AUTH",
        "ERR_TIMEOUT",
        "ERR_UNKNOWN",
        "ERR_TIMEOUT",
        "ERR_AUTH"
    ]

    target_error = "ERR_AUTH"
    count = 0

    for error in error_logs:
        if target_error == error:
            count += 1

    print(f"The required count: {count}")


"""

### ✅ **3. Scenario: Database Migration – Find Common Columns**

**Context**:
You are working on migrating data from an old system to a new one. Before migrating, you need to find out which
**column names** are common between two database schemas. Both schemas provide you lists of column names.

**Task**:
Write a function that takes two lists of strings and returns the list of common elements.

schema1_columns = ["user_id", "email", "created_at", "last_login", "status"]
schema2_columns = ["status", "email", "password", "signup_source"]

# Expected common columns: ["email", "status"]

"""
def q3():
    schema1_columns = ["user_id", "email", "created_at", "last_login", "status", "loginCreds","loginCREDS"]
    schema2_columns = ["status", "email", "password", "signup_source", "loginCreds"]

    common_ele = set()

    for sc1_ele in schema1_columns:
        if sc1_ele in schema2_columns:
            common_ele.add(sc1_ele)

    print(f"List of common elements: {list(common_ele)}")


"""

### ✅ **4. Scenario: CI/CD Pipeline – Check Build Name Format**

**Context**:
In your CI/CD pipeline, build names must follow a convention:
They should start with a **prefix** (e.g., `"build_"`) and be immediately followed by **numeric digits**
(e.g., `"build_1024"`).

You need to verify whether a given build name follows this pattern.

**Task**:
Write a function to check if a given build name string starts with `"build_"` and is followed only by digits.

build_names = [
    "build_1024",         # Valid
    "build_001",          # Valid
    "build_XYZ",          # Invalid (non-digit suffix)
    "release_1001",       # Invalid (wrong prefix)
    "build_",             # Invalid (no digits)
    "build_12a4",         # Invalid (contains a letter)
    " build_123",         # Invalid (leading space)
]

1. How do I create a regex pattern matching the given string.
2. How do I compare whether this pattern matches with my string?
"""
import re

def q4():
    build_names = [
        "build_1024",  # Valid
        "build_001",  # Valid
        "build_XYZ",  # Invalid (non-digit suffix)
        "release_1001",  # Invalid (wrong prefix)
        "build_",  # Invalid (no digits)
        "build_12a4",  # Invalid (contains a letter)
        " build_123",  # Invalid (leading space)
    ]

    req_pattern = r"^build_\d+$"

    for build in build_names:
        if re.fullmatch(req_pattern, build.strip()):
            print(f"Build name: {build} matches the 'build_number*' pattern!")
        else:
            print(f"Build name: {build} DOES NOT MATCH the 'build_number*' pattern!")


"""

### ✅ **5. Scenario: Cloud Billing – Total Monthly Cost**

**Context**:
You are generating a billing report where each service’s monthly cost is given in a dictionary with the service name as
the key and cost as the value. Your task is to find the **total monthly cloud cost** by summing all values in the
dictionary.

**Task**:
Write a function that returns the sum of all values in the dictionary.

cloud_costs = {
    "Compute Engine": 1200,
    "Cloud Storage": 450,
    "BigQuery": 800,
    "Cloud Functions": 300,
    "Monitoring": 150
}

# Expected total cost: 1200 + 450 + 800 + 300 + 150 = 2900

---
"""
def q5():
    cloud_costs = {
        "Compute Engine": 1200,
        "Cloud Storage": 450,
        "BigQuery": 800,
        "Cloud Functions": 300,
        "Monitoring": 150
    }
    total_bill = 0

    for service in cloud_costs.keys():
        total_bill += cloud_costs[service]

    print(f"The total bill is Rs {total_bill}")


if __name__ == '__main__':
    q5()

